title:

Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.
Find all the elements of [1, n] inclusive that do not appear in this array.
Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.

idea: set the appearing number minus 

version 1;

public class Solution 
{
    public List<Integer> findDisappearedNumbers(int[] nums) 
    {
        int [] result = new int [nums.length];
        for (int i; i < nums.length; i++)
        {
              
        }
    }
}

problem1 : Line 15： should be List 
List<Integer> ret = new ArrayList<Integer>();

version 2:

public class Solution 
{
    public List<Integer> findDisappearedNumbers(int[] nums) 
    {
        List<Integer> result = new List<Integer> ();
        
        
        // firstly, set all the number appearring negative
        for (int i; i < nums.length; i++)
        {    
             // find the index of the nums 
             int idx = Math.abs(nums[i]) - 1;

             // set the number negative
             if (nums[i]>0)
             {
                 nums[i] = -nums[i];
             }
             nums[val] = nums[i];  // wired!
        }
        
        for (int i; i < nums.length; i++)
        {
              
        }
    }
}










